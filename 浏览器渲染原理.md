# **浏览器渲染原理**

#### 输入网址到渲染页面

有三阶段

1. HTTP请求阶段

   > DNS解析
   >
   > TCP协议三次握手和四次挥手
   >
   > HTTPS和HTTP的区别

2. HTTP响应阶段

> HTTP状态码

> HTTP报文

> 缓存机制、304缓存（性能优化）

3. 浏览器渲染阶段（单线程，进栈执行，执行完出栈）

#### 第一次自上而下走完后，只生成DOM树

1. 开辟栈内存，用来给代码执行提供环境，同时分配一个主线程（js单线程的原因）一行行去解析和执行代码

2. ==当浏览器遇到<link><img><script><video><audio>等需要请求外部资源的标签时都会开启新的线程去加载资源文件==`浏览器是多线程的，但只会分配一个线程去执行代码`并将这些请求写入等待任务队列（task queue）

3. 执行完所有HTML标签代码后，CSS不一定返回

#### 然后主线程回去任务队列查找加载任务（Event Loop事件循环机制）

`等待任务队列里还涉及微任务和宏任务，所有微任务要限于宏任务执行`

1. 先按顺序解析已经加载完的数据，解析完之后再回去任务对列查找未执行任务，直至任务执行完毕
2. CSS处理完时，生成CSSOM树

#### 再将DOM树和CSSOM树结合，生成Render Tree（渲染树），进行Layout（回流），Painting（重绘）

==回流一定会重绘==

1. 回流（Rflow）：根据视口大小，计算元素的确切位置和大小

   > 只触发回流：元素大小或位置发生变化，触发重新布局，导致render树重新计算布局和渲染，内容发生变化，文本变化，图片尺寸变化等`displace,浏览器窗口改变`

2. 重绘（Repaint）：根据渲染树以及回流得到的几何信息，得到节点的绝对像素

   > 只触发重绘：元素的样式改变，但宽高、大小、位置不变 `outiine/visibility/background-color`

3. 进行渲染

---

#### 性能优化

**核心：减少HTTP的请求次数和大小**

##### 1.资源合并压缩

css，js文件等

##### 2.图片懒加载

第一次生成DOM树时不加载图片，等进行完回流，重绘，渲染完成后，再去先把第一屏的请求回来渲染，后面的滚动到对应区域再加载

##### 3.音视频文件走流文件

先加载一部分，走m3u8等等

---

##### 减少回流重绘

##### 1.避免操作DOM

vue、react

mvvm、mvc、virtual dom、dom diff

##### 2.分离读写

当代浏览器有渲染队列机制，连续改变样式时，浏览器会将任务放入渲染队列里，之后统一渲染

==操作样式和读取样式分开写==

##### 3.集中样式改变

box.style.cssText = "  " 或者 直接加类名

##### 4.缓存布局信息

将读取操作用变量缓存

##### 5.元素批量处理

**文档碎片**

document.createDocumentFragment()，文档碎片容器

将要添加的元素，先添加文档碎片容器中，再放入页面中

**模板**

使用模板字符串拼接